#!/usr/bin/env node
var config = require('./utils/get-config')();
var PathsExist = require('./utils/paths-exist');
var exec = require('./utils/exec');
var path = require('path');
var glob = require('glob');
var semver = require('semver');
var fs = require('fs');
var log = require('./utils/log');
var CommanderWrapper = require('./utils/commander-wrapper');
var versions = [
  'major',
  'minor',
  'patch',
  'premajor',
  'preminor',
  'prepatch',
  'prerelease'
];

// check if we are being run with npm
if ('npm_config_username' in process.env || 'npm_package_name' in process.env || 'npm_config_heading' in process.env) {
  var npmArgs = JSON.parse(process.env.npm_config_argv);
  // check if the user is doing npm version and error if they are
  if (npmArgs.cooked[0] === 'version') {
    log.fatal('sb-release does not support npm version <newversion>. Only use it in the following ways');
    log.fatal('* run it directly: `sb-release <newversion>`');
    log.fatal('* use it as an npm script: `npm run version <newversion>`');
    process.exit(1);
  }
}

var program = CommanderWrapper(function(commander) {
  return commander
    .option('-d, --dry-run', 'print which commands would be run')
    .arguments('<new-version>')
    .description('' +
      '<newversion> is any valid semver (except the current one) examples:\n' +
      '  * A valid semver version: X.X.X\n' +
      '  * A valid semver word: major, minor, etc.')
    .action(function(newVersion) {
      this.newVersion = newVersion;
    });
});

if (!program.newVersion) {
  log.fatal('Must pass in a new-version');
  process.exit(1);
}

if ((versions.indexOf(program.newVersion) === -1 && !semver.valid(program.newVersion)) ||
    program.newVersion === config.version) {
  log.fatal('new-version must be valid semver identifier');
  log.fatal('and it cannot be the current version');
  process.exit(1);
}

if (versions.indexOf(program.newVersion) !== -1) {
  program.newVersion = semver.inc(config.version, program.newVersion);
}


if (!PathsExist(path.join(config.path, '.git'))) {
  log.fatal('Your project must be a git repository');
  process.exit(1);
}

var changelog = glob.sync(path.join(config.path, 'CHANGELOG.md'), {nocase: true})[0];
if (!changelog) {
  log.error('Your project must contain a CHANGELOG in the root');
  process.exit(1);
}

// reset config to current package version that npm set
// var version = semver.

// change package.json
if (!program.dryRun) {
  var pkg = JSON.parse(fs.readFileSync(path.join(config.path, 'package.json'), 'utf8'));
  pkg.version = program.newVersion;
  fs.writeFileSync(path.join(config.path, 'package.json'), JSON.stringify(pkg, null, 2));
}

var commands = [
  ['chg', 'release', program.newVersion],
  ['git', 'add', '--all'],
  ['git', 'commit', '-a', '-m', program.newVersion]
];

var bowerSupport = PathsExist(path.join(config.path, 'bower.json'));

// If the project supports Bower, perform special extra versioning step.
if (bowerSupport) {
  commands.push(['sb-build']);
}

if (bowerSupport) {
  commands.push(['git', 'add', '-f', config.dist]);
  commands.push(['git', 'commit', '-a', '-m', program.newVersion]);
}

commands.push(['git', 'tag', '-f', 'v' + program.newVersion]);

if (bowerSupport) {
  commands.push(['git', 'reset', 'HEAD~1']);
}

commands.forEach(function(command) {
  log.info('running: ' + command.join(' '));
  if (!program.dryRun) {
    exec(command, {silent: true});
  }
});

log.info(program.newVersion + ' is ready for release. Run the following to push to the remote repo:');
log.info('git push --tags');
log.info('git push');
log.info('sb-build');
log.info('npm publish');
