#!/usr/bin/env node
var config = require('./utils/get-config')();
var PathsExist = require('./utils/paths-exist');
var path = require('path');
var GetPath = require('./utils/get-path');
var glob = require('glob');
var semver = require('semver');
var shelljs = require('shelljs');
var fs = require('fs');
var log = require('./utils/log');
var CommanderWrapper = require('./utils/commander-wrapper');
var versions = [
  'major',
  'minor',
  'patch',
  'premajor',
  'preminor',
  'prepatch',
  'prerelease'
];

// check if we are being run with npm
if ('npm_config_username' in process.env || 'npm_package_name' in process.env || 'npm_config_heading' in process.env) {
  var npmArgs = JSON.parse(process.env.npm_config_argv);
  // check if the user is doing npm version and error if they are
  if (npmArgs.cooked[0] === 'version') {
    log.fatal('sb-release does not support npm version <newversion>. Only use it in the following ways');
    log.fatal('* run it directly: `sb-release <newversion>`');
    log.fatal('* use it as an npm script: `npm run version <newversion>`');
    process.exit(1);
  }
}


var program = CommanderWrapper(function(commander) {
  return commander
    .option('-d, --dry-run', 'print which commands would be run')
    .arguments('<new-version>')
    .description(''
    + '<newversion> is any valid semver (except the current one) examples:\n'
    + '  * A valid semver version: X.X.X\n'
    + '  * A valid semver word: major, minor, etc.')
    .action(function(newVersion) {
      this.newVersion = newVersion;
    });
});

if (!program.newVersion) {
  log.fatal('Must pass in a new-version');
  process.exit(1);
}

if ((versions.indexOf(program.newVersion) === -1 && !semver.valid(program.newVersion)) ||
    program.newVersion === config.version) {
  log.fatal('new-version must be valid semver identifier');
  log.fatal('and it cannot be the current version');
  process.exit(1);
}

if (versions.indexOf(program.newVersion) !== -1) {
  program.newVersion = semver.inc(config.version, program.newVersion);
}


if (!PathsExist(path.join(config.path, '.git'))) {
  log.fatal('Your project must be a git repository');
  process.exit(1);
}

var changelog = glob.sync(path.join(config.path, 'CHANGELOG.md'), {nocase: true})[0];
if (!changelog) {
  log.error('Your project must contain a CHANGELOG in the root');
  process.exit(1);
}

shelljs.config.silent = true;

// reset config to current package version that npm set
// var version = semver.

// change package.json
if (!program.dryRun) {
  var pkg = JSON.parse(fs.readFileSync(path.join(config.path, 'package.json'), 'utf8'));
  pkg.version = program.newVersion;
  fs.writeFileSync(path.join(config.path, 'package.json'), JSON.stringify(pkg, null, 2));
}

var commands = [
  GetPath('chg') + ' release ' + program.newVersion,
  'git add --all',
];

commands.push('git commit -a -m ' + program.newVersion);

var bowerSupport = PathsExist(path.join(config.path, 'bower.json'));

// If the project supports Bower, perform special extra versioning step.
if (bowerSupport) {
  commands.push(GetPath('sb-build'));
  commands.push('git add -f ' + config.dist);
  commands.push('git commit -a --amend -m ' + program.newVersion);
}

commands.push('git tag -f v' + program.newVersion);

if (bowerSupport) {
  commands.push('git rm -rf dist');
  commands.push('git commit -a --amend -m ' + program.newVersion);
}

commands.forEach(function(command) {
  if (!program.quiet) {
    log.info('running ' + command);
  }
  if (!program.dryRun) {
    shelljs.exec(command);
  }
});

// this mimics the npm version post commands
shelljs.popd(config.path);

if (!program.quiet) {
  log.info('Released ' + program.newVersion + ' run the following to push to the remote repo:');
  log.info('git push --tags && git push');
}
