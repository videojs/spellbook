#!/usr/bin/env node
var config = require('./utils/get-config')();
var path = require('path');
var log = require('./utils/log');
var Run = require('./utils/run');
var CommanderWrapper = require('./utils/commander-wrapper');
var Promise = require('bluebird');
var KarmaServer = require('karma').Server;
var Watch = require('./utils/watch');
var debounce = require('lodash.debounce');
var findBrowser = require('./sb-test-browser-utils/find-browser');

var program = CommanderWrapper(function(commander) {
  return commander
    .option('-w, --watch', 'keep the tester running and run as things change')
    .option('-b, --browsers <list,of,browsers>', 'comma seperated list of browsers to run on')
    .option('-nb, --no-build', 'dont build before testing')
    .option('-p, --port <port>', 'port for karma server')
    .option('-nl, --no-lint', 'dont lint before testing');
});

program.port = program.port || process.env.TEST_PORT || 9876;

var karmaConfig = {browsers: []};
if (program.browsers) {
  var KARMA_BROWSERS = ['Chrome', 'Firefox', 'IE', 'Safari'];

  program.browsers.split(',').forEach(function(userBrowser) {
    var i = findBrowser(KARMA_BROWSERS, userBrowser);

    if (i === -1) {
      log.fatal('invalid browser entry: ' + userBrowser);
      return process.exit(1);
    }

    karmaConfig.browsers.push(KARMA_BROWSERS[i]);
  });
}

// support various configurations
karmaConfig = require('./sb-test-browser-utils/karma')(program, config, karmaConfig);
karmaConfig = require('./sb-test-browser-utils/browserstack')(program, config, karmaConfig);
karmaConfig = require('./sb-test-browser-utils/travis')(program, config, karmaConfig);
karmaConfig = require('./sb-test-browser-utils/teamcity')(program, config, karmaConfig);
karmaConfig = require('./sb-test-browser-utils/detect-browsers')(program, config, karmaConfig);

var buildPromise = Promise.resolve();
if (program.build && !program.watch) {
  buildPromise = Run.one('sb-build');
}

buildPromise.then(function() {
  if (program.lint && !program.watch) {
    return Run.one(['sb-lint'], {nonFatal: true});
  }
  return Promise.resolve();
}).then(function(retval) {
  var lintingFail = false;
  if (retval && retval.status && retval.status !== 0) {
    lintingFail = true;
  }

  var server = new KarmaServer(karmaConfig, function(exitCode) {
    // always return failure if linting failed
    // unless this is during --watch
    if (!program.watch && lintingFail) {
      exitCode = 1;
    }
    process.exit(exitCode)
  });

  server.start();

  if (program.watch) {
    var patterns = karmaConfig.files.map(function(obj) {
      return obj.pattern;
    });
    Watch(patterns, debounce(function() {
      server.refreshFiles();
    }, 1000));
  }

});

